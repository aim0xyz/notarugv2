<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>notarug-roulette</title>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-color: #10101a;
        --card-bg-color: #1c1c2b;
        --primary-accent: #6d28d9;
        --primary-accent-hover: #5b21b6;
        --secondary-accent: #37375a;
        --border-color: #2a2a4a;
        --text-color: #f0f0f0;
        --subtle-text-color: #88889a;
        --danger: #ef4444;
        --success: #14b8a6;
        --gold-highlight: #8b5cf6;
        --yellow-color: #ffeb3b;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Orbitron", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        padding: 1rem;
        display: flex;
        justify-content: center;
        overflow-x: hidden;
      }
      #app-container {
        width: 100%;
        max-width: 450px;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }
      button,
      input {
        font-family: "Orbitron", sans-serif;
        cursor: pointer;
        border: none;
      }
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .logo {
        font-size: 1.25rem;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        perspective: 1000px;
      }
      .logo svg {
        width: 40px;
        height: 40px;
        animation: logoRotate3D 4s linear infinite;
        transform-style: preserve-3d;
        filter: drop-shadow(0 0 10px rgba(139, 92, 246, 0.5));
      }
      @keyframes logoRotate3D {
        0% { 
          transform: rotateY(0deg) rotateX(0deg) translateZ(0px);
        }
        25% { 
          transform: rotateY(90deg) rotateX(10deg) translateZ(5px);
        }
        50% { 
          transform: rotateY(180deg) rotateX(0deg) translateZ(0px);
        }
        75% { 
          transform: rotateY(270deg) rotateX(-10deg) translateZ(5px);
        }
        100% { 
          transform: rotateY(360deg) rotateX(0deg) translateZ(0px);
        }
      }
      .header-actions {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        position: relative;
        flex-wrap: wrap;
      }
      .balance-display {
        background-color: var(--secondary-accent);
        padding: 0.5rem 1rem;
        border-radius: 8px;
        font-weight: 500;
        font-size: 0.85rem;
        white-space: nowrap;
      }
      .connect-btn {
        background-color: var(--primary-accent);
        color: white;
        padding: 0.6rem 1rem;
        border-radius: 8px;
        font-weight: 600;
        transition: background-color 0.3s ease;
      }
      .connect-btn:hover {
        background-color: var(--primary-accent-hover);
      }
      .claim-btn {
        background-color: #10b981;
        color: white;
        padding: 0.6rem 1rem;
        border-radius: 8px;
        font-weight: 600;
        transition: background-color 0.3s ease;
        border: none;
        cursor: pointer;
        font-size: 0.85rem;
        white-space: nowrap;
      }
      .claim-btn:hover {
        background-color: #059669;
      }
      .claim-btn:disabled {
        background-color: #6b7280;
        cursor: not-allowed;
      }
      main {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .outcomes-display {
        display: flex;
        gap: 8px;
        padding-bottom: 10px;
        overflow-x: auto;
        flex-direction: row;
      }
      .outcomes-display::-webkit-scrollbar {
        height: 4px;
      }
      .outcomes-display::-webkit-scrollbar-thumb {
        background: var(--secondary-accent);
        border-radius: 2px;
      }
      .outcomes-display .tile {
        width: 50px;
        height: 50px;
        font-size: 0.8rem;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--card-bg-color);
      }
      .timer-display {
        text-align: center;
        font-size: 1.2rem;
        font-weight: 600;
        color: var(--gold-highlight);
        padding: 0.75rem;
        background: var(--card-bg-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }
      .wheel-wrap {
        margin-top: 0.5rem;
        overflow: hidden;
        border: 1px solid var(--border-color);
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.3);
        position: relative;
        height: 110px;
      }
      .marker {
        position: absolute;
        inset: 0;
        width: 4px;
        height: 100%;
        margin: 0 auto;
        background: var(--gold-highlight);
        z-index: 1;
        box-shadow: 0 0 9px 2px var(--gold-highlight);
        border-radius: 2px;
      }
      .stripe {
        display: flex;
        position: absolute;
        left: 0;
        top: 0;
        height: 110px;
        align-items: center;
        will-change: transform;
      }
      .tile {
        flex: 0 0 auto;
        width: 80px;
        height: 80px;
        margin: 0 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        border: 2px solid #333;
        border-radius: 10px;
        background: var(--secondary-accent);
        font-size: 1rem;
        text-shadow: 1px 1px 2px #000;
        transition: transform 0.3s;
        position: relative;
        z-index: 2;
      }
      .red {
        color: var(--danger);
        border-color: var(--danger);
      }
      .gray {
        color: #bdbdbd;
        border-color: #757575;
      }
      .green {
        color: var(--success);
        border-color: var(--success);
      }
      .yellow {
        color: var(--yellow-color);
        border-color: var(--yellow-color);
      }
      .gold {
        color: var(--gold-highlight);
        border-color: var(--gold-highlight);
      }
      .hit {
        outline: 3px solid var(--gold-highlight);
        transform: scale(1.1);
        z-index: 3;
        box-shadow: 0 0 15px var(--gold-highlight);
      }
      .controls {
        background-color: var(--card-bg-color);
        border-radius: 12px;
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        border: 1px solid var(--border-color);
      }
      .controls .row {
        display: flex;
        gap: 1rem;
        align-items: center;
      }
      .input-wrap {
        flex: 1;
        display: flex;
        flex-direction: column;
      }
      .input-wrap label {
        font-size: 0.8rem;
        color: var(--subtle-text-color);
        margin-bottom: 4px;
      }
      .controls input {
        width: 100%;
        padding: 0.75rem;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background: var(--bg-color);
        color: var(--text-color);
        text-align: center;
        font-size: 1rem;
        font-weight: 600;
      }
      .controls input:focus {
        outline: none;
        border-color: var(--primary-accent);
      }
      .btn {
        width: 100%;
        padding: 0.8rem 0.5rem;
        font-weight: 700;
        border-radius: 8px;
        transition: 0.2s;
        font-size: 1rem;
      }
      .btn.primary {
        background-color: var(--primary-accent);
        color: white;
      }
      .btn.primary:not(:disabled):hover {
        background-color: var(--primary-accent-hover);
      }
      .btn.sec {
        background-color: var(--secondary-accent);
        color: var(--text-color);
      }
      .btn.sec:not(:disabled):hover {
        background-color: #4a4a7a;
      }
      .btn:disabled {
        cursor: not-allowed;
        background: #2e2e3f !important;
        color: #666;
        transform: none;
        box-shadow: none;
      }
      .side-panel {
        background: var(--card-bg-color);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 1rem;
      }
      .side-panel h4 {
        margin: 0 0 0.8rem;
        text-align: center;
        color: var(--text-color);
        font-weight: 600;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.8rem;
      }
      .bet-list {
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 150px;
        overflow-y: auto;
        flex-grow: 1;
      }
      .bet-list::-webkit-scrollbar {
        width: 4px;
      }
      .bet-list::-webkit-scrollbar-thumb {
        background: var(--secondary-accent);
        border-radius: 2px;
      }
      .bet-list li {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem;
        border-radius: 5px;
        margin-bottom: 0.4rem;
        background: rgba(0, 0, 0, 0.3);
        font-size: 0.8rem;
      }
      .bet-list li.win {
        background: rgba(20, 184, 166, 0.2);
        color: var(--success);
      }
      .bet-list li.loss {
        background: rgba(239, 68, 68, 0.2);
        color: var(--danger);
      }
      .fairness-info {
        margin-top: 1rem;
        padding: 0.8rem;
        background: var(--card-bg-color);
        border-radius: 8px;
        font-size: 0.75rem;
        text-align: center;
        font-family: monospace;
        word-break: break-all;
        border: 1px solid var(--border-color);
      }
      .fairness-info strong {
        color: var(--subtle-text-color);
      }
      .recent-bets {
        background-color: var(--card-bg-color);
        border-radius: 12px;
        padding: 1rem;
        border: 1px solid var(--border-color);
      }
      .recent-bets h4 {
        margin: 0 0 0.8rem;
        text-align: center;
        font-weight: 500;
        font-size: 0.9rem;
        color: var(--subtle-text-color);
      }
      .recent-bets-container {
        display: flex;
        justify-content: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .recent-bet-btn {
        background-color: var(--secondary-accent);
        color: var(--text-color);
        padding: 0.4rem 0.8rem;
        border-radius: 6px;
        font-size: 0.75rem;
        transition: background-color 0.2s ease;
      }
      .recent-bet-btn:hover {
        background-color: #4a4a7a;
      }
      .popup {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        animation: fade 0.35s;
        z-index: 999;
        backdrop-filter: blur(5px);
      }
      .popup h2 {
        font-size: 3.5rem;
        margin: 0 0 0.2rem;
        animation: pulse 1.5s infinite;
      }
      .popup .win-amt {
        font-size: 1.8rem;
        color: var(--success);
        margin-top: 0;
        font-weight: 600;
      }
      @keyframes fade {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
      @keyframes confetti-fall {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(100vh) rotate(720deg);
          opacity: 0;
        }
      }
      .confetti {
        position: fixed;
        top: -20px;
        pointer-events: none;
        z-index: 1000;
        animation: confetti-fall 3s linear forwards;
      }
      /* Profile dropdown */
      .profile-dropdown {
        position: relative;
        display: none;
      }
      .profile-dropdown-button {
        background-color: var(--secondary-accent);
        color: white;
        border-radius: 8px;
        font-weight: 600;
        padding: 0.6rem 1rem;
        cursor: pointer;
      }
      .profile-dropdown-button:disabled {
        cursor: not-allowed;
      }
      .profile-dropdown-content {
        display: none;
        position: absolute;
        top: 100%;
        right: 0;
        z-index: 1000;
        min-width: 250px;
        background-color: var(--card-bg-color);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem;
      }
      .profile-dropdown.show .profile-dropdown-content {
        display: block;
      }
      .profile-section {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .profile-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .profile-row span {
        color: var(--subtle-text-color);
        font-size: 0.8rem;
      }
      .profile-picture {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        overflow: hidden;
        border: 1px solid var(--border-color);
        background: var(--secondary-accent);
        display: inline-block;
        background-size: cover;
        background-position: center;
      }
      #profile-pic-image {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .profile-username-input,
      .profile-pic-input {
        background-color: var(--bg-color);
        color: var(--text-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        font-size: 0.8rem;
        padding: 0.5rem;
      }
      /* Responsive Design */
      @media (max-width: 480px) {
        body {
          padding: 0.5rem;
        }
        #app-container {
          max-width: 100%;
        }
        .header-actions {
          gap: 0.5rem;
        }
        .profile-dropdown-content {
          position: fixed;
          top: 60px;
          right: 0.5rem;
          left: 0.5rem;
          min-width: auto;
          max-width: none;
          z-index: 1001;
        }
        .profile-dropdown-button {
          padding: 0.5rem 0.8rem;
          font-size: 0.9rem;
        }
        .balance-display {
          font-size: 0.75rem;
          padding: 0.4rem 0.8rem;
        }
        .connect-btn {
          padding: 0.5rem 0.8rem;
          font-size: 0.85rem;
        }
        .claim-btn {
          padding: 0.5rem 0.8rem;
          font-size: 0.75rem;
        }
        .controls {
          padding: 1rem;
        }
        .popup h2 {
          font-size: 2.5rem;
        }
        .popup .win-amt {
          font-size: 1.4rem;
        }
        .logo {
          font-size: 1rem;
        }
        .logo svg {
          width: 32px;
          height: 32px;
          animation: logoRotate3D 4s linear infinite;
          transform-style: preserve-3d;
          filter: drop-shadow(0 0 8px rgba(139, 92, 246, 0.5));
        }
      }
    </style>
  </head>
  <body>
    <div id="app-container">
      <header>
        <div class="logo">
          <svg
            width="100"
            height="100"
            viewBox="0 0 100 100"
            xmlns="http://www.w3.org/2000/svg"
          >
            <defs>
              <radialGradient
                id="owl-glow-clean"
                cx="50%"
                cy="50%"
                r="50%"
                fx="50%"
                fy="50%"
              >
                <stop offset="0%" style="stop-color:#a855f7; stop-opacity:1" />
                <stop offset="100%" style="stop-color:#8b5cf6; stop-opacity:1" />
              </radialGradient>
            </defs>
            <path
              d="M50 20 C 30 20, 20 40, 20 55 C 20 80, 40 90, 50 90 C 60 90, 80 80, 80 55 C 80 40, 70 20, 50 20 Z"
              fill="#37375a"
            />
            <path
              d="M50 20 C 70 20, 80 40, 80 55 L 20 55 C 20 40, 30 20, 50 20 Z"
              fill="#6d28d9"
            />
            <circle cx="38" cy="45" r="8" fill="#1c1c2b" />
            <circle cx="62" cy="45" r="8" fill="#1c1c2b" />
            <circle cx="38" cy="45" r="4" fill="url(#owl-glow-clean)" />
            <circle cx="62" cy="45" r="4" fill="url(#owl-glow-clean)" />
            <polygon points="50,50 55,60 45,60" fill="#f0f0f0" />
          </svg>
          <span>notarug</span>
        </div>
        <div class="header-actions">
          <div class="balance-display">
            Balance: \$<span id="bal-header">100.00</span>
          </div>
          <button class="connect-btn" id="connect-wallet-btn">Connect</button>
          <div class="profile-dropdown" id="profile-dropdown">
            <button class="profile-dropdown-button" id="profile-dropdown-button" disabled>
              Profile
            </button>
            <div class="profile-dropdown-content" id="profile-dropdown-content">
              <div class="profile-section">
                <div class="profile-row">
                  <div class="profile-picture">
                    <img id="profile-pic-image" src="" alt="Profile" />
                  </div>
                  <div>
                    <input
                      type="file"
                      id="profile-pic-input"
                      class="profile-pic-input"
                      accept="image/*"
                    />
                  </div>
                </div>
                <div class="profile-row">
                  <span>Username:</span>
                  <input
                    type="text"
                    id="username-input"
                    class="profile-username-input"
                    placeholder="Enter your username"
                  />
                  <button class="btn sec" id="update-profile-btn">Update</button>
                </div>
                <div class="profile-row" style="gap:1rem;">
                  <button class="btn sec" id="deposit-btn">Deposit</button>
                  <button class="btn sec" id="withdraw-btn">Withdraw</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </header>
      <main>
        <!-- Outcomes display: showing the 10 last outcomes -->
        <div class="outcomes-display" id="outcomes-display"></div>
        <div class="timer-display" id="timer">Starting new round...</div>
        <div class="wheel-wrap">
          <div class="marker"></div>
          <div class="stripe" id="stripe"></div>
        </div>
        <div class="controls">
          <div class="row">
            <div class="input-wrap">
              <label for="bet">Bet Amount (\$)</label>
              <input id="bet" type="text" value="1.00" />
            </div>
            <div class="input-wrap">
              <label for="target">Target Multiplier (x)</label>
              <input id="target" type="text" value="1.50" />
            </div>
          </div>
          <div class="row">
            <button class="btn primary" id="placeBetBtn">Place Bet (0/10)</button>
          </div>
          <div class="row">
            <button class="btn sec" id="autoBetBtn">Autobet: OFF</button>
          </div>
        </div>
        <div class="recent-bets">
          <h4>Recent Bets</h4>
          <div class="recent-bets-container" id="recent-bets-container"></div>
        </div>
        <div class="side-panel">
          <h4>Live Bets</h4>
          <ul id="my-bets-list" class="bet-list"></ul>
        </div>
        <div class="fairness-info">
          <div>
            <strong>Round Hash:</strong> <span id="hash-display"></span>
          </div>
          <div style="margin-top: 5px;">
            <strong>Previous Seed:</strong> <span id="seed-display">Not available yet.</span>
          </div>
        </div>
      </main>
    </div>
    <audio
      id="sSpin"
      src="https://assets.mixkit.co/sfx/preview/mixkit-slot-machine-spin-1930.mp3"
      preload="auto"
    ></audio>
    <audio
      id="sWin"
      src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3"
      preload="auto"
    ></audio>
    <audio
      id="sLose"
      src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-retro-game-over-213.mp3"
      preload="auto"
    ></audio>
    <audio
      id="sTick"
      src="https://assets.mixkit.co/sfx/preview/mixkit-retro-game-notification-212.mp3"
      preload="auto"
    ></audio>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const ROUND_TIME = 20,
          SPIN_DURATION_MS = 5000,
          RESULT_DELAY_MS = 4000,
          TILES_PER_SPIN = 80,
          ROTATIONS_PER_SPIN = 3,
          MAX_BETS_PER_ROUND = 10,
          MAX_MULTIPLIER = 10000,
          DAILY_CLAIM_AMOUNT = 100;
  
        let balance = 100.0,
          nonce = 0,
          clientSeed = "",
          roundState = "init",
          countdown = ROUND_TIME,
          timerId,
          serverSeed,
          serverSeedHash,
          previousServerSeed,
          pastOutcomes = [],
          myBetsThisRound = [],
          autoBetsSaved = [],
          autobetActive = false;
  
        let recentBets = [];
  
        // Profile variables
        let playerUsername = "Player";
        let profilePicDataUrl = "";
        let isConnected = false;
        let connectedWalletAddress = null;
        let currentUserId = null;
        let currentRoundId = null;
        let canClaimDaily = false;
        let nextClaimTime = null;
  
        const ui = {
          stripe: document.querySelector("#stripe"),
          timer: document.querySelector("#timer"),
          betInput: document.querySelector("#bet"),
          targetInput: document.querySelector("#target"),
          hashDisplay: document.querySelector("#hash-display"),
          seedDisplay: document.querySelector("#seed-display"),
          outcomesDisp: document.querySelector("#outcomes-display"),
          balHeader: document.querySelector("#bal-header"),
          myBetsList: document.querySelector("#my-bets-list"),
          placeBtn: document.querySelector("#placeBetBtn"),
          autoBtn: document.querySelector("#autoBetBtn"),
          connectBtn: document.querySelector("#connect-wallet-btn"),
          recentBetsContainer: document.querySelector("#recent-bets-container"),
          profilePicInput: document.querySelector("#profile-pic-input"),
          profilePicImage: document.querySelector("#profile-pic-image"),
          usernameInput: document.querySelector("#username-input"),
          updateProfileBtn: document.querySelector("#update-profile-btn"),
          depositBtn: document.querySelector("#deposit-btn"),
          withdrawBtn: document.querySelector("#withdraw-btn"),
          profileDropdownButton: document.querySelector("#profile-dropdown-button"),
          profileDropdown: document.querySelector("#profile-dropdown"),
          profileDropdownContent: document.querySelector("#profile-dropdown-content"),
          claimBtn: document.querySelector(".claim-btn")
        };
  
        // Use Web Crypto API for SHA-256 hashing
        const sha256 = async (str) => {
          const buf = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(str));
          return Array.from(new Uint8Array(buf))
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
        };
  
        const genSeed = () => crypto.randomUUID();
        const playSound = (sel) => {
          const a = document.querySelector(sel);
          if (a) {
            a.currentTime = 0;
            a.play().catch(() => {});
          }
        };
  
        // API calls for Node.js serverless functions on Vercel
        const api = {
          async createUser(userData) {
            const response = await fetch("/api/user", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(userData)
            });
            return await response.json();
          },
          async getUser(userId) {
            const response = await fetch(`/api/user/${userId}`);
            return await response.json();
          },
          async claimDaily(userId) {
            const response = await fetch(`/api/user/${userId}/claim`, {
              method: "POST"
            });
            return await response.json();
          },
          async startRound() {
            const response = await fetch("/api/game/start-round", {
              method: "POST"
            });
            return await response.json();
          },
          async placeBet(userId, betAmount, targetMultiplier) {
            const response = await fetch("/api/game/place-bet", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                user_id: userId,
                bet_amount: betAmount,
                target_multiplier: targetMultiplier
              })
            });
            return await response.json();
          },
          async endRound(resultMultiplier) {
            const response = await fetch("/api/game/end-round", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                result_multiplier: resultMultiplier
              })
            });
            return await response.json();
          },
          async getRecentOutcomes() {
            const response = await fetch("/api/game/recent-outcomes");
            return await response.json();
          },
          async getRecentBets(userId) {
            const response = await fetch(`/api/user/${userId}/recent-bets`);
            return await response.json();
          },
          async getLiveBets() {
            const response = await fetch("/api/game/live-bets");
            return await response.json();
          },
          async claimDailyBalance(userId) {
            const response = await fetch(`/api/user/${userId}/claim-daily`, {
              method: "POST",
              headers: { "Content-Type": "application/json" }
            });
            return await response.json();
          }
        };
  
        const updateBalance = () => (ui.balHeader.textContent = balance.toFixed(2));
  
        const colorClass = (m) =>
          m < 1.01
            ? "red"
            : m < 3.0
            ? "gray"
            : m < 10.0
            ? "green"
            : m < 20.0
            ? "yellow"
            : "gold";
  
        const themeColorHex = {
          red: "#ef4444",
          gray: "#bdbdbd",
          green: "#14b8a6",
          yellow: "#ffeb3b",
          gold: "#8b5cf6"
        };
  
        const getHexColor = (m) => themeColorHex[colorClass(m)] || "#f0f0f0";
  
        function enforceNumericInput(event) {
          const input = event.target;
          let value = input.value.replace(/[^0-9.]/g, "");
          const parts = value.split(".");
          if (parts.length > 2) value = parts[0] + "." + parts.slice(1).join("");
          input.value = value;
        }
  
        // Updated proven result function with modified odds:
        //  • ~50% chance of falling between 1.01x and 3.00x
        //  • ~30% chance for 3.00x to 10x
        //  • ~10% chance for 10x-20x (more common than above 20x)
        //  • ~5% chance for 20x-100x
        //  • ~3% chance for 100x-1000x
        //  • ~1.5% chance for 1000x-10000x
        //  • Remaining for 10000x exactly
        function getProvenResult() {
          const timestamp = Date.now();
          const currentClientSeed = clientSeed || Math.random().toString(36).substring(2, 15);
          const combinedSeed = serverSeedHash + nonce.toString() + timestamp.toString() + currentClientSeed;
  
          let randomValue;
          if (window.crypto && window.crypto.getRandomValues) {
            const array = new Uint32Array(1);
            window.crypto.getRandomValues(array);
            randomValue = array[0] / 4294967295;
          } else {
            let hash = 0;
            for (let i = 0; i < combinedSeed.length; i++) {
              const char = combinedSeed.charCodeAt(i);
              hash = ((hash << 5) - hash) + char;
              hash = hash & hash;
            }
            randomValue = Math.abs(hash) % 1000000 / 1000000;
          }
          const additionalEntropy = Math.random() * 0.1;
          const r = (randomValue + additionalEntropy) % 1.0;
  
          if (r < 0.50) {
            // 50% chance for 1.01x to 3.00x
            return +(1.01 + (r / 0.50) * (3.00 - 1.01)).toFixed(2);
          } else if (r < 0.80) {
            // 30% chance for 3.00x to 10x
            return +(3.00 + ((r - 0.50) / 0.30) * (10.00 - 3.00)).toFixed(2);
          } else if (r < 0.90) {
            // 10% chance for 10x to 20x (more common than above 20)
            return +(10.00 + ((r - 0.80) / 0.10) * (20.00 - 10.00)).toFixed(2);
          } else if (r < 0.95) {
            // 5% chance for 20x to 100x
            return +(20.00 + ((r - 0.90) / 0.05) * (100.00 - 20.00)).toFixed(2);
          } else if (r < 0.98) {
            // 3% chance for 100x to 1000x
            return +(100.00 + ((r - 0.95) / 0.03) * (1000.00 - 100.00)).toFixed(2);
          } else if (r < 0.995) {
            // 1.5% chance for 1000x to 10000x
            return +(1000.00 + ((r - 0.98) / 0.015) * (10000.00 - 1000.00)).toFixed(2);
          } else {
            // Remaining falls exactly on 10000x
            return 10000.0;
          }
        }
  
        async function startNewRound() {
          myBetsThisRound = [];
          ui.myBetsList.innerHTML = "";
          setState("betting");
  
          try {
            // Get a new round from the backend (with a new server seed)
            const roundData = await api.startRound();
            currentRoundId = roundData.round_id;
            serverSeedHash = roundData.server_seed_hash;
            nonce = roundData.nonce;
            clientSeed = roundData.client_seed;
  
            ui.hashDisplay.textContent = serverSeedHash.substring(0, 32) + "...";
            if (previousServerSeed)
              ui.seedDisplay.textContent = previousServerSeed;
  
            if (!pastOutcomes || pastOutcomes.length === 0) {
              const outcomes = await api.getRecentOutcomes();
              pastOutcomes = outcomes;
            }
            updateOutcomesDisplay();
          } catch (error) {
            console.error("Error starting new round:", error);
          }
          countdown = ROUND_TIME;
          handleCountdown();
          timerId = setInterval(handleCountdown, 1000);
  
          if (autobetActive && autoBetsSaved.length)
            autoBetsSaved.forEach((b) => executeBet(b.amount, b.target, true));
  
          ui.autoBtn.textContent = autobetActive
            ? `Autobet: ON (${autoBetsSaved.length})`
            : `Autobet: OFF`;
        }
  
        function handleCountdown() {
          ui.timer.textContent = `Spinning in ${countdown}s`;
          if (countdown <= 5 && countdown > 0) playSound("#sTick");
          if (countdown <= 0) {
            clearInterval(timerId);
            startSpin();
          }
          countdown--;
        }
  
        function startSpin() {
          setState("spinning");
          playSound("#sSpin");
          const result = getProvenResult();
          ui.stripe.innerHTML = "";
          const totalTiles = TILES_PER_SPIN * (ROTATIONS_PER_SPIN + 1);
          const landingIndex = ROTATIONS_PER_SPIN * TILES_PER_SPIN + Math.floor(TILES_PER_SPIN / 2);
          let tiles = [];
  
          for (let i = 0; i < totalTiles; i++) {
            let m = i === landingIndex
              ? result
              : Math.random() < 0.6
                ? +(Math.random() * 0.98 + 1.01).toFixed(2)
                : Math.random() < 0.95
                  ? +(Math.random() * 7.99 + 2.0).toFixed(2)
                  : Math.random() < 0.99
                    ? +(Math.random() * 89.99 + 10.0).toFixed(2)
                    : +(Math.random() * (MAX_MULTIPLIER - 100) + 100).toFixed(2);
  
            let tileEl = document.createElement("div");
            tileEl.className = `tile ${colorClass(m)}`;
            tileEl.textContent = `${Number(m).toFixed(2)}x`;
            ui.stripe.appendChild(tileEl);
            tiles.push(tileEl);
          }
  
          const tileWidth = tiles[0].offsetWidth + 8;
          const wheelWidth = ui.stripe.parentElement.offsetWidth;
          const centerOffset = (wheelWidth - tileWidth) / 2;
          const finalShift = landingIndex * tileWidth - centerOffset;
  
          ui.stripe.style.transition = "none";
          ui.stripe.style.transform = "translateX(0)";
          requestAnimationFrame(() => {
            ui.stripe.style.transition = `transform ${SPIN_DURATION_MS / 1000}s cubic-bezier(.22,1,.36,1)`;
            ui.stripe.style.transform = `translateX(${-finalShift}px)`;
          });
          setTimeout(() => {
            tiles[landingIndex].classList.add("hit");
            showResult(result);
          }, SPIN_DURATION_MS);
        }
  
        function triggerConfetti() {
          const confettiCount = 100;
          const colors = ["#6d28d9", "#8b5cf6", "#14b8a6", "#ffeb3b", "#f0f0f0"];
          for (let i = 0; i < confettiCount; i++) {
            const confetti = document.createElement("div");
            confetti.classList.add("confetti");
            confetti.style.left = `${Math.random() * 100}vw`;
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animationDelay = `${Math.random() * 1.5}s`;
            const size = `${Math.random() * 8 + 5}px`;
            confetti.style.width = size;
            confetti.style.height = size;
            confetti.style.opacity = `${Math.random() + 0.5}`;
            document.body.appendChild(confetti);
            setTimeout(() => confetti.remove(), 3500);
          }
        }
  
        async function showResult(res) {
          setState("result");
          try {
            const roundResult = await api.endRound(res);
            if (roundResult.previous_seed) {
              previousServerSeed = roundResult.previous_seed;
            }
  
            let totalWon = 0;
            roundResult.bet_results.forEach((betResult) => {
              const localBet = myBetsThisRound.find(b => b.betId === betResult.bet_id);
              if (localBet) {
                if (betResult.is_win) {
                  totalWon += betResult.win_amount;
                  localBet.li.classList.add("win");
                  localBet.li.querySelector(".bet-outcome").textContent = `+${betResult.win_amount.toFixed(2)}`;
                } else {
                  localBet.li.classList.add("loss");
                  localBet.li.querySelector(".bet-outcome").textContent = `-${betResult.bet_amount.toFixed(2)}`;
                }
              }
            });
  
            if (currentUserId) {
              try {
                const userData = await api.getUser(currentUserId);
                balance = userData.balance;
              } catch (error) {
                console.error("Error updating balance:", error);
              }
            }
  
            pastOutcomes.unshift(res);
            // Keep only last 10 outcomes
            if (pastOutcomes.length > 10) pastOutcomes = pastOutcomes.slice(0, 10);
  
            updateOutcomesDisplay();
            updateBalance();
            nonce = roundResult.nonce;
  
            if (totalWon > 0) {
              const hexColor = getHexColor(res);
              let p = document.createElement("div");
              p.className = "popup";
              p.innerHTML = `<h2 style="color:${hexColor}; text-shadow: 0 0 15px ${hexColor};">${res.toFixed(2)}×</h2><div class="win-amt">+${totalWon.toFixed(2)}</div>`;
              document.body.appendChild(p);
              playSound("#sWin");
              triggerConfetti();
              setTimeout(() => p.remove(), 2800);
            } else if (myBetsThisRound.length) {
              playSound("#sLose");
            }
          } catch (error) {
            console.error("Error ending round:", error);
          }
          setTimeout(startNewRound, RESULT_DELAY_MS);
        }
  
        function renderRecentBets() {
          ui.recentBetsContainer.innerHTML = "";
          recentBets.forEach((bet) => {
            const btn = document.createElement("button");
            btn.className = "recent-bet-btn";
            btn.textContent = `\$${bet.bet_amount.toFixed(2)} @ ${bet.target_multiplier.toFixed(2)}x`;
            btn.onclick = () => executeBet(bet.bet_amount, bet.target_multiplier);
            ui.recentBetsContainer.appendChild(btn);
          });
        }
  
        function updateOutcomesDisplay() {
          ui.outcomesDisp.innerHTML = "";
          if (pastOutcomes && pastOutcomes.length > 0) {
            pastOutcomes.forEach((o) => {
              let el = document.createElement("div");
              el.className = `tile ${colorClass(o)}`;
              el.textContent = `${o.toFixed(2)}x`;
              ui.outcomesDisp.appendChild(el);
            });
          }
        }
  
        async function executeBet(amount, target, isAutobet = false) {
          if (roundState !== "betting" || myBetsThisRound.length >= MAX_BETS_PER_ROUND)
            return;
          if (!isConnected) {
            if (!isAutobet) alert("Please connect your Solana wallet first to place bets.");
            return;
          }
          if (isNaN(amount) || amount < 0.1 || amount > balance) {
            if (!isAutobet) alert("Invalid bet amount or insufficient balance.");
            return;
          }
          if (isNaN(target) || target <= 1.0 || target > 1000) {
            if (!isAutobet)
              alert("Target must be greater than 1.00× and no more than 1000×.");
            return;
          }
          if (!currentUserId) {
            if (!isAutobet) alert("Please create a profile first.");
            return;
          }
  
          try {
            const betResult = await api.placeBet(currentUserId, amount, target);
            if (betResult.error) {
              if (!isAutobet) alert(betResult.error);
              return;
            }
            balance = betResult.new_balance;
            updateBalance();
  
            let li = document.createElement("li");
            li.innerHTML = `<span>${playerUsername} - \$${amount.toFixed(2)} @ ${target.toFixed(2)}×</span><span class="bet-outcome">Pending</span>`;
            ui.myBetsList.prepend(li);
            myBetsThisRound.push({ 
              betAmount: amount, 
              target: target, 
              li: li,
              betId: betResult.bet_id 
            });
  
            if (!isAutobet) {
              const betExists = recentBets.some(
                (b) => b.bet_amount === amount && b.target_multiplier === target
              );
              if (!betExists) {
                recentBets.unshift({ bet_amount: amount, target_multiplier: target });
                if (recentBets.length > 10) recentBets.pop();
                renderRecentBets();
              }
            }
  
            updateBetButtonState();
            if (autobetActive && !isAutobet) {
              autoBetsSaved = myBetsThisRound.map((b) => ({
                amount: b.betAmount,
                target: b.target,
              }));
              ui.autoBtn.textContent = `Autobet: ON (${autoBetsSaved.length})`;
            }
          } catch (error) {
            console.error("Error placing bet:", error);
            if (!isAutobet) alert("Error placing bet. Please try again.");
          }
        }
  
        function placeBetFromUI() {
          const amount = parseFloat(ui.betInput.value);
          const target = parseFloat(ui.targetInput.value);
          executeBet(amount, target);
        }
  
        function toggleAutobet() {
          autobetActive = !autobetActive;
          if (autobetActive && myBetsThisRound.length > 0) {
            autoBetsSaved = myBetsThisRound.map((b) => ({
              amount: b.betAmount,
              target: b.target,
            }));
          } else if (!autobetActive) {
            autoBetsSaved = [];
          }
          ui.autoBtn.textContent = autobetActive
            ? `Autobet: ON (${autoBetsSaved.length})`
            : "Autobet: OFF";
        }
  
        function updateBetButtonState() {
          const betCount = myBetsThisRound.length;
          if (!isConnected) {
            ui.placeBtn.textContent = "Connect Wallet to Bet";
            ui.placeBtn.disabled = true;
          } else {
            ui.placeBtn.textContent = `Place Bet (${betCount}/${MAX_BETS_PER_ROUND})`;
            ui.placeBtn.disabled = betCount >= MAX_BETS_PER_ROUND;
          }
        }
  
        function setState(newState) {
          roundState = newState;
          const isBetting = newState === "betting";
          const canBet = isBetting && isConnected;
          ui.placeBtn.disabled = !canBet;
          ui.betInput.disabled = !canBet;
          ui.targetInput.disabled = !canBet;
          ui.autoBtn.disabled = !canBet;
          
          if (isBetting) {
            updateBetButtonState();
            ui.timer.textContent = `Spinning in ${ROUND_TIME}s`;
          } else {
            ui.timer.textContent = newState === "spinning" ? "Spinning..." : "Round Over!";
          }
        }
  
        async function connectSolanaWallet() {
          try {
            // Force test wallet simulation if Phantom is not available.
            if (!window.solana || !window.solana.isPhantom) {
              console.warn("Phantom wallet not detected; using test simulation.");
              return simulateWalletConnection();
            }
  
            const response = await window.solana.connect();
            const publicKey = response.publicKey.toString();
            const message = `Verify wallet ownership for NotaRug Roulette\nTimestamp: ${Date.now()}`;
            const encodedMessage = new TextEncoder().encode(message);
            const signedMessage = await window.solana.signMessage(encodedMessage, "utf8");
  
            const verificationResponse = await fetch("/api/wallet/verify", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                publicKey: publicKey,
                message: message,
                signature: Array.from(signedMessage.signature)
              })
            });
  
            if (!verificationResponse.ok) {
              throw new Error("Wallet verification failed");
            }
  
            await updateUserProfile(playerUsername, profilePicDataUrl, publicKey);
            isConnected = true;
            connectedWalletAddress = publicKey;
  
            ui.connectBtn.textContent = "Wallet Connected";
            ui.connectBtn.disabled = true;
            ui.connectBtn.style.backgroundColor = "#10b981";
            ui.profileDropdownButton.disabled = false;
            ui.profileDropdown.style.display = "inline-block";
            updateWalletDisplay(publicKey);
            setState(roundState);
            updateBetButtonState();
            updateClaimButtonState();
  
            console.log("Wallet connected and verified:", publicKey);
          } catch (error) {
            console.error("Failed to connect wallet:", error);
            alert("Failed to connect wallet. Please try again.");
          }
        }
  
        async function disconnectWallet() {
          try {
            if (window.solana) {
              await window.solana.disconnect();
            }
            isConnected = false;
            connectedWalletAddress = null;
  
            ui.connectBtn.textContent = "Connect Wallet";
            ui.connectBtn.disabled = false;
            ui.connectBtn.style.backgroundColor = "#8b5cf6";
            ui.profileDropdownButton.disabled = true;
            ui.profileDropdown.style.display = "none";
            updateWalletDisplay(null);
            setState(roundState);
            updateBetButtonState();
            updateClaimButtonState();
  
            console.log("Wallet disconnected");
          } catch (error) {
            console.error("Failed to disconnect wallet:", error);
          }
        }
  
        async function simulateWalletConnection() {
          try {
            const fakeWalletAddress = "5" + Math.random().toString(36).substring(2, 15).padEnd(43, "0");
            await updateUserProfile(playerUsername, profilePicDataUrl, fakeWalletAddress);
            isConnected = true;
            connectedWalletAddress = fakeWalletAddress;
  
            ui.connectBtn.textContent = "Wallet Connected (Test)";
            ui.connectBtn.disabled = true;
            ui.connectBtn.style.backgroundColor = "#10b981";
            ui.profileDropdownButton.disabled = false;
            ui.profileDropdown.style.display = "inline-block";
            updateWalletDisplay(fakeWalletAddress);
            setState(roundState);
            updateBetButtonState();
            updateClaimButtonState();
  
            console.log("Test wallet connected:", fakeWalletAddress);
          } catch (error) {
            console.error("Failed to simulate wallet connection:", error);
            alert("Failed to connect test wallet. Please try again.");
          }
        }
  
        function updateWalletDisplay(walletAddress) {
          let walletSection = document.getElementById("wallet-section");
  
          if (!walletSection) {
            const profileContent = document.querySelector("#profile-dropdown-content");
            if (profileContent) {
              walletSection = document.createElement("div");
              walletSection.id = "wallet-section";
              walletSection.innerHTML = `
                <h3>Wallet</h3>
                <div id="wallet-address">No wallet connected</div>
                <button id="disconnect-wallet-btn" class="btn sec" style="display: none;" onclick="disconnectWallet()">Disconnect Wallet</button>
              `;
              profileContent.appendChild(walletSection);
            }
          }
  
          const walletAddressDiv = document.getElementById("wallet-address");
          const disconnectBtn = document.getElementById("disconnect-wallet-btn");
  
          if (walletAddressDiv && disconnectBtn) {
            if (walletAddress) {
              walletAddressDiv.textContent = `${walletAddress.slice(0, 6)}...${walletAddress.slice(-4)}`;
              disconnectBtn.style.display = "inline-block";
            } else {
              walletAddressDiv.textContent = "No wallet connected";
              disconnectBtn.style.display = "none";
            }
          }
        }
  
        async function claimDailyBalance() {
          if (!isConnected || !canClaimDaily) return;
          try {
            ui.claimBtn.disabled = true;
            ui.claimBtn.textContent = "Claiming...";
  
            const result = await api.claimDailyBalance(currentUserId);
  
            if (result.success) {
              balance = result.user.balance;
              canClaimDaily = result.user.can_claim_daily;
              nextClaimTime = result.user.next_claim_time;
  
              updateBalance();
              updateClaimButtonState();
  
              alert(`Daily balance claimed! +\$${result.claimed_amount}`);
            } else {
              alert(result.error || "Failed to claim daily balance");
            }
          } catch (error) {
            console.error("Error claiming daily balance:", error);
            alert("Error claiming daily balance. Please try again.");
          } finally {
            ui.claimBtn.disabled = false;
          }
        }
  
        function updateClaimButtonState() {
          if (!isConnected) {
            if(ui.claimBtn) ui.claimBtn.style.display = "none";
            return;
          }
  
          if(ui.claimBtn) ui.claimBtn.style.display = "inline-block";
  
          if (canClaimDaily) {
            if(ui.claimBtn) {
              ui.claimBtn.textContent = "Claim \$100";
              ui.claimBtn.disabled = false;
            }
          } else if (nextClaimTime) {
            const now = new Date();
            const claimTime = new Date(nextClaimTime);
            const timeDiff = claimTime.getTime() - now.getTime();
            if (timeDiff > 0) {
              const hours = Math.floor(timeDiff / (1000 * 60 * 60));
              const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
              if(ui.claimBtn) {
                ui.claimBtn.textContent = `${hours}h ${minutes}m`;
                ui.claimBtn.disabled = true;
              }
            } else {
              if(ui.claimBtn) {
                ui.claimBtn.textContent = "Claim \$100";
                ui.claimBtn.disabled = false;
              }
              canClaimDaily = true;
            }
          } else {
            if(ui.claimBtn) {
              ui.claimBtn.textContent = "Claim \$100";
              ui.claimBtn.disabled = false;
            }
          }
        }
  
        async function depositFromWallet() {
          alert("Deposit from wallet on Solana mainnet (stub)...");
        }
  
        async function withdrawToWallet() {
          alert("Withdraw to your Solana mainnet wallet (stub)...");
        }
  
        async function claimDaily() {
          if (!currentUserId) {
            alert("Please create a profile first.");
            return;
          }
          try {
            const result = await api.claimDaily(currentUserId);
  
            if (result.error) {
              alert(result.error);
            } else {
              balance = result.new_balance;
              updateBalance();
              alert(`You have claimed \$${DAILY_CLAIM_AMOUNT.toFixed(2)}. Enjoy!`);
            }
          } catch (error) {
            console.error("Error claiming daily bonus:", error);
            alert("Error claiming daily bonus. Please try again.");
          }
        }
  
        async function updateProfile() {
          const newUsername = ui.usernameInput.value.trim();
          if (!newUsername) {
            alert("Please enter a username.");
            return;
          }
          try {
            if (profilePicDataUrl) {
              ui.profilePicImage.src = profilePicDataUrl;
              ui.profilePicImage.style.display = "block";
            }
  
            const userData = {
              username: newUsername,
              balance: balance,
              profile_picture: profilePicDataUrl,
              wallet_address: connectedWalletAddress,
              is_connected: isConnected
            };
  
            const result = await api.createUser(userData);
  
            if (result.error) {
              alert(result.error);
            } else {
              currentUserId = result.id;
              playerUsername = result.username;
              balance = result.balance;
              canClaimDaily = result.can_claim_daily;
              nextClaimTime = result.next_claim_time;
  
              updateBalance();
              updateClaimButtonState();
              loadRecentBets();
  
              ui.usernameInput.value = "";
              alert("Profile updated successfully!");
  
              ui.profileDropdown.classList.remove("show");
            }
          } catch (error) {
            console.error("Error updating profile:", error);
            alert("Error updating profile. Please try again.");
          }
        }
  
        async function loadRecentBets() {
          if (!currentUserId) return;
          try {
            const userRecentBets = await api.getRecentBets(currentUserId);
            recentBets = userRecentBets;
            renderRecentBets();
          } catch (error) {
            console.error("Error loading recent bets:", error);
          }
        }
  
        function toggleProfileDropdown() {
          ui.profileDropdown.classList.toggle("show");
        }
  
        ui.betInput.addEventListener("input", enforceNumericInput);
        ui.targetInput.addEventListener("input", enforceNumericInput);
        ui.placeBtn.addEventListener("click", placeBetFromUI);
        ui.autoBtn.addEventListener("click", toggleAutobet);
        ui.connectBtn.addEventListener("click", connectSolanaWallet);
        updateWalletDisplay(null);
  
        async function updateUserProfile(username, profilePic, walletAddress = null) {
          try {
            const userData = {
              username: username,
              profile_picture: profilePic,
              balance: balance
            };
  
            if (walletAddress) {
              userData.wallet_address = walletAddress;
              userData.is_connected = true;
            }
  
            const response = await api.createUser(userData);
            currentUserId = response.id;
            balance = response.balance;
            canClaimDaily = response.can_claim_daily;
            nextClaimTime = response.next_claim_time;
  
            updateBalance();
            updateClaimButtonState();
  
            return response;
          } catch (error) {
            console.error("Error updating user profile:", error);
            throw error;
          }
        }
  
        ui.depositBtn.addEventListener("click", depositFromWallet);
        ui.withdrawBtn.addEventListener("click", withdrawToWallet);
        ui.updateProfileBtn.addEventListener("click", updateProfile);
  
        ui.profilePicInput.addEventListener("change", (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev) => {
            profilePicDataUrl = ev.target.result;
            ui.profilePicImage.src = profilePicDataUrl;
            ui.profilePicImage.style.display = "block";
          };
          reader.readAsDataURL(file);
        });
  
        ui.profileDropdownButton.addEventListener("click", toggleProfileDropdown);
        document.addEventListener("click", (event) => {
          if (!ui.profileDropdown.contains(event.target)) {
            ui.profileDropdown.classList.remove("show");
          }
        });
  
        async function initializeGame() {
          ui.profileDropdown.style.display = "none";
          try {
            const newUser = await api.createUser({
              username: "Player",
              balance: 100.0,
              is_connected: false
            });
  
            currentUserId = newUser.id;
            playerUsername = newUser.username;
            balance = newUser.balance;
            canClaimDaily = newUser.can_claim_daily;
            nextClaimTime = newUser.next_claim_time;
  
            updateBalance();
            updateClaimButtonState();
            await loadRecentBets();
  
            try {
              const outcomes = await api.getRecentOutcomes();
              pastOutcomes = outcomes;
              updateOutcomesDisplay();
            } catch (error) {
              console.error("Error loading past outcomes:", error);
            }
  
            await startNewRound();
          } catch (error) {
            console.error("Error initializing game:", error);
            updateBalance();
            renderRecentBets();
            startNewRound();
          }
        }
  
        initializeGame();
  
        setInterval(updateClaimButtonState, 60000);
      });
    </script>
  </body>
</html>